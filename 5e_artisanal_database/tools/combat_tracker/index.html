<!DOCTYPE html>
<!--
The code for this tool is released under a CC0 1.0 Universal license. You can copy, modify, and distribute this tool, even for commercial purposes, all without asking permission.
Learn about the licensing of the data of this tool in the license.html file located in the root director of this application.
-->
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
<meta name="robots" content="noindex">
<meta charset="UTF-8">
<link rel="stylesheet" href="../../css_js/5eadb.css">
<style>
/* Combat Tracker specific styles */

/* Use standard fonts and larger text */
body {
    font-family: Arial, sans-serif !important;
    font-size: 16px !important;
}

/* Make all interactive elements larger */
input, textarea, select, a {
    font-size: 16px !important;
    font-family: Arial, sans-serif !important;
}

button {
    font-size: 16px !important;
    font-family: Arial, sans-serif !important;
    box-sizing: border-box !important;
}

/* Remove spinner arrows from all number inputs */
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
input[type=number] {
    -moz-appearance: textfield;
}

table {
    width: 100%;
    margin: 10px 0;
    font-size: 16px;
    table-layout: auto;
}

th, td {
    border: 1px solid #999;
    padding: 6px;
    vertical-align: middle;
}

th {
    background-color: #e0e0e0;
    font-weight: bold;
    font-size: 16px;
}

.init-col {
    width: min-content;
}
.name-col {
    min-width: 230px;
}
.ac-col {
    width: 45px;
}
.hp-col {
    width: 270px;
    min-width: 100px;
}

.controls {
    margin: 10px 0;
    padding: 8px;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    border-radius: 4px;
}

.controls h3 {
    margin: 0 0 8px 0;
    font-size: 16px;
}

.controls input {
    margin: 2px;
    padding: 6px;
    font-size: 16px;
    background-color: white;
    color: black;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.hp-controls {
    display: flex;
    align-items: center;
    gap: 2px;
    flex-wrap: wrap;
}

.hp-controls button {
    background-color: #666;
    color: white;
    border: none;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 16px;
    margin: 0;
    min-width: 28px;
    border-radius: 4px;
}

.hp-controls button:hover {
    background-color: #555;
}

.hp-controls input {
    width: 50px;
    font-size: 16px;
    text-align: center;
    margin: 0;
    padding: 3px;
    background-color: white;
    color: black;
    border: 1px solid #ccc;
    border-radius: 4px;
}

.hp-controls span {
    font-size: 16px;
    margin: 0 2px;
}

.current-turn {
    background-color: #d0d0d0;
    font-weight: bold;
}

.remove-btn {
    background-color: #666;
    color: white;
    border: none;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    border-radius: 4px;
}

.remove-btn:hover {
    background-color: #555;
}

.combat-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    justify-content: center;
    margin: 10px 0;
}

.combat-controls button {
    background-color: #666;
    color: white;
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 16px;
    flex: 1;
    min-width: 70px;
    max-width: 100px;
    border-radius: 4px;
    min-height: 32px;
}

.combat-controls button:hover {
    background-color: #555;
}
</style>
<title>Combat Tracker - 5e Artisanal Database</title>
<script src="../../css_js/monster_encounter_stats.js"></script>
<script src="monsters.js"></script>
</head>
<body>
<div><a href="../../index.html">5e Artisanal Database</a> â†’ Combat Tracker</div>

<h1>Combat Tracker</h1>

<div class="controls">
    <h3>Add Combatant</h3>
    <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: flex-start;">
        <div style="position: relative; width: 250px;">
            <input type="text" id="nameInput" placeholder="Name or search monsters..." required>
            <div id="monsterResults" style="position: absolute; top: 100%; left: 0; right: 0; max-height: 200px; overflow-y: auto; border: 1px solid #999; background-color: white; display: none; z-index: 1000;">
            </div>
        </div>
        <select id="monsterSource" onchange="loadMonstersFromSource()" style="width: 200px;">
            <option value="">Loading sources...</option>
        </select>
    </div>
    <input type="number" id="initiativeInput" placeholder="Initiative (optional)" min="0" max="30">
    <input type="number" id="maxHpInput" placeholder="Max HP (optional)" min="1">
    <input type="number" id="acInput" placeholder="AC (optional)" min="1" max="30">
    <input type="number" id="quantityInput" placeholder="Qty" min="1" max="20" value="1" style="width: 50px;">
    <button onclick="addCombatant()">Add Combatant</button>
</div>

<div class="combat-controls">
    <button onclick="nextTurn()">Next Turn</button>
    <button onclick="resetCombat()">Reset</button>
    <input type="file" id="importFile" accept=".json" style="display: none" onchange="importCombat(event)">
    <button onclick="document.getElementById('importFile').click()">Import JSON</button>
    <button onclick="exportCombat()">Export JSON</button>
    <button onclick="copyInitiativeText()">Copy Text</button>
</div>

<table id="combatTable">
    <thead>
        <tr>
            <th class="init-col">Init</th>
            <th class="name-col">Name</th>
            <th class="ac-col">AC</th>
            <th class="hp-col">HP</th>
        </tr>
    </thead>
    <tbody id="combatBody">
    </tbody>
</table>

<script>
let combatants = [];
let currentTurnIndex = 0;
let allMonsters = [];
let monsters = [];
let monsterSources = [];
let selectedSource = '';

// Load monster data from included JavaScript
function loadMonstersFromJS() {
    try {
        // Check if monster data is available (loaded from monsters.js)
        if (typeof combatTrackerMonsters === 'undefined') {
            throw new Error('Monster data not loaded. Make sure monsters.js is included.');
        }
        
        allMonsters = combatTrackerMonsters;
        monsterSources = combatTrackerSources || [];
        
        // Populate source selector
        populateSourceSelector();
        
        // Load all monsters initially
        loadMonstersFromSource();
        
        return true;
    } catch (error) {
        // Fall back to dummy data
        return loadDummyMonsters();
    }
}

// Fallback dummy monster data
function loadDummyMonsters() {
    const dummyMonsters = [
        { name: "Goblin", ac: 15, hp: 7, init: 2, source: "5.1 SRD (2015 MM)" },
        { name: "Orc", ac: 13, hp: 15, init: 1, source: "5.1 SRD (2015 MM)" },
        { name: "Hobgoblin", ac: 18, hp: 11, init: 1, source: "5.1 SRD (2015 MM)" },
        { name: "Bugbear", ac: 16, hp: 27, init: 2, source: "5.1 SRD (2015 MM)" },
        { name: "Ogre", ac: 11, hp: 59, init: -1, source: "5.1 SRD (2015 MM)" },
        { name: "Troll", ac: 15, hp: 84, init: 0, source: "5.1 SRD (2015 MM)" },
        { name: "Hill Giant", ac: 13, hp: 105, init: -1, source: "5.1 SRD (2015 MM)" },
        { name: "Stone Giant", ac: 17, hp: 126, init: 2, source: "5.1 SRD (2015 MM)" },
        { name: "Fire Giant", ac: 18, hp: 162, init: 0, source: "5.1 SRD (2015 MM)" },
        { name: "Frost Giant", ac: 15, hp: 138, init: 0, source: "5.1 SRD (2015 MM)" }
    ];
    
    allMonsters = dummyMonsters;
    monsterSources = ["5.1 SRD (2015 MM)"];
    
    populateSourceSelector();
    loadMonstersFromSource();
    return false;
}

// Populate the source selector dropdown
function populateSourceSelector() {
    const sourceSelect = document.getElementById('monsterSource');
    sourceSelect.innerHTML = '<option value="">All Sources</option>';
    
    monsterSources.forEach(source => {
        const option = document.createElement('option');
        option.value = source;
        option.textContent = source;
        sourceSelect.appendChild(option);
    });
}

// Load monsters from selected source
function loadMonstersFromSource() {
    const sourceSelect = document.getElementById('monsterSource');
    selectedSource = sourceSelect.value;
    
    if (selectedSource === '') {
        // All sources
        monsters = allMonsters;
    } else {
        // Filter by selected source
        monsters = allMonsters.filter(monster => monster.source === selectedSource);
    }
}

let selectedMonsterIndex = -1;
let filteredMonsters = [];

// Function to create monster link if it exists in database
function getMonsterLink(combatant) {
    // Use the stored original monster info if available, otherwise fall back to name matching
    let monsterName, monsterSource;
    
    if (combatant.originalMonsterName && combatant.monsterSource) {
        monsterName = combatant.originalMonsterName;
        monsterSource = combatant.monsterSource;
    } else {
        // Fall back to name matching for backwards compatibility
        const baseName = combatant.name.replace(/\s+[A-Z]$/, '');
        const monster = allMonsters.find(m => {
            const cleanName = m.name.replace(/\s*\([^)]+\)$/, '');
            return cleanName.toLowerCase() === baseName.toLowerCase();
        });
        
        if (!monster) {
            return '';
        }
        
        monsterName = baseName;
        monsterSource = monster.source;
    }
    
    if (monsterName && monsterSource) {
        // Create URL-friendly monster name based on source
        let urlName = '';
        let sourceDir = '';
        
        switch(monsterSource) {
            case '5.1 SRD (2015 MM)':
                sourceDir = '5.1_srd_(2015_mm)';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');
                break;
            case '5.2 SRD (2025 MM)':
                sourceDir = '5.2_srd_(2025_mm)';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '_')
                    .replace(/[^a-z0-9_]/g, '') + '_mm_2024';
                break;
            case 'A5e Monstrous Menagerie':
                sourceDir = 'a5e_monstrous_menagerie';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '') + '-a5e';
                break;
            case 'Black Flag':
                sourceDir = 'black_flag';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');
                break;
            case 'Creature Codex':
                sourceDir = 'creature_codex';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');
                break;
            case 'Tome of Beasts 2':
                sourceDir = 'tome_of_beasts_2';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');
                break;
            case 'Tome of Beasts 2023':
                sourceDir = 'tome_of_beasts_2023';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');
                break;
            case 'Tome of Beasts 3':
                sourceDir = 'tome_of_beasts_3';
                urlName = monsterName.toLowerCase()
                    .replace(/'/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');
                break;
            default:
                return ''; // No link if unknown source
        }
        
        const url = `../../monsters/html/${sourceDir}/${urlName}.html`;
        return `<button onclick="window.open('${url}', '_blank')" title="View monster stats" style="position: absolute; right: 35px; background-color: #666 !important; color: white !important; border: none !important; padding: 3px 8px !important; cursor: pointer; font-size: 16px !important; border-radius: 3px !important; line-height: 16px !important; height: auto !important; min-height: auto !important; box-sizing: border-box !important;">stats</button>`;
    }
    
    return ''; // No link button if monster not found
}

function searchMonsters() {
    const searchTerm = document.getElementById('nameInput').value.toLowerCase().trim();
    const resultsDiv = document.getElementById('monsterResults');
    
    if (searchTerm.length < 2) {
        resultsDiv.style.display = 'none';
        selectedMonsterIndex = -1;
        filteredMonsters = [];
        return;
    }
    
    filteredMonsters = monsters.filter(monster => 
        monster.name.toLowerCase().includes(searchTerm)
    ).slice(0, 15);
    
    if (filteredMonsters.length === 0) {
        resultsDiv.style.display = 'none';
        selectedMonsterIndex = -1;
        return;
    }
    
    selectedMonsterIndex = -1; // Reset selection
    renderMonsterResults();
    resultsDiv.style.display = 'block';
}

function renderMonsterResults() {
    const resultsDiv = document.getElementById('monsterResults');
    resultsDiv.innerHTML = filteredMonsters.map((monster, index) => 
        `<div style="padding: 4px; cursor: pointer; border-bottom: 1px solid #ddd; font-size: 16px; ${index === selectedMonsterIndex ? 'background-color: #e0e0e0;' : ''}" 
              onclick="selectMonsterByIndex(${index})"
              onmouseover="this.style.backgroundColor='#f0f0f0'" 
              onmouseout="this.style.backgroundColor='${index === selectedMonsterIndex ? '#e0e0e0' : 'white'}'">
            <strong>${monster.name}</strong> - AC ${monster.ac}, HP ${monster.hp}, Init ${monster.init >= 0 ? '+' + monster.init : monster.init}
         </div>`
    ).join('');
}

function selectMonsterByIndex(index) {
    if (index >= 0 && index < filteredMonsters.length) {
        const monster = filteredMonsters[index];
        selectMonster(monster.name, monster.ac, monster.hp, monster.init);
    }
}

function selectMonster(name, ac, hp, init) {
    // Remove source abbreviation from name (everything in parentheses at the end)
    const cleanName = name.replace(/\s*\([^)]+\)$/, '');
    
    // Find the monster in our database to get its source
    const monster = allMonsters.find(m => m.name === name);
    
    // Check how many of this monster type already exist
    const existingCount = combatants.filter(c => c.name.startsWith(cleanName)).length;
    
    let finalName = cleanName;
    if (existingCount > 0) {
        const suffix = String.fromCharCode(65 + existingCount);
        finalName = `${cleanName} ${suffix}`;
    }
    
    document.getElementById('nameInput').value = finalName;
    document.getElementById('acInput').value = ac;
    document.getElementById('maxHpInput').value = hp;
    document.getElementById('initiativeInput').value = 10 + init;
    document.getElementById('monsterResults').style.display = 'none';
    document.getElementById('quantityInput').focus();
    
    // Store the monster info globally so addCombatant can use it
    window.selectedMonsterInfo = {
        originalName: cleanName,
        source: monster ? monster.source : null
    };
}

// Hide monster results when clicking outside
document.addEventListener('click', function(event) {
    const resultsDiv = document.getElementById('monsterResults');
    const nameInput = document.getElementById('nameInput');
    if (!resultsDiv.contains(event.target) && event.target !== nameInput) {
        resultsDiv.style.display = 'none';
    }
});

// Add event listener for monster search in name field
document.addEventListener('DOMContentLoaded', function() {
    const nameInput = document.getElementById('nameInput');
    if (nameInput) {
        nameInput.addEventListener('input', searchMonsters);
        
        // Add keyboard navigation
        nameInput.addEventListener('keydown', function(event) {
            const resultsDiv = document.getElementById('monsterResults');
            
            if (resultsDiv.style.display === 'none' || filteredMonsters.length === 0) {
                return;
            }
            
            switch(event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    selectedMonsterIndex = Math.min(selectedMonsterIndex + 1, filteredMonsters.length - 1);
                    renderMonsterResults();
                    break;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    selectedMonsterIndex = Math.max(selectedMonsterIndex - 1, -1);
                    renderMonsterResults();
                    break;
                    
                case 'Enter':
                    // Only handle Enter if a monster is selected, otherwise let it pass through
                    if (selectedMonsterIndex >= 0) {
                        event.preventDefault();
                        selectMonsterByIndex(selectedMonsterIndex);
                    }
                    // If no monster selected, let the general Enter handler move to next field
                    break;
                    
                case 'Escape':
                    resultsDiv.style.display = 'none';
                    selectedMonsterIndex = -1;
                    break;
            }
        });
    }
});

function addCombatant() {
    const name = document.getElementById('nameInput').value.trim();
    const initiative = parseInt(document.getElementById('initiativeInput').value) || 0;
    const maxHp = parseInt(document.getElementById('maxHpInput').value) || null;
    const ac = parseInt(document.getElementById('acInput').value) || null;
    const quantity = parseInt(document.getElementById('quantityInput').value) || 1;
    
    if (!name) {
        alert('Please fill in Name.');
        return;
    }
    
    if (quantity < 1 || quantity > 20) {
        alert('Quantity must be between 1 and 20.');
        return;
    }
    
    // Get existing count for this monster type
    const existingCount = combatants.filter(c => c.name.startsWith(name)).length;
    
    // Add multiple combatants
    for (let i = 0; i < quantity; i++) {
        let finalName = name;
        
        // If adding multiple, or if name already exists, add suffix
        if (quantity > 1 || existingCount > 0) {
            const suffix = String.fromCharCode(65 + existingCount + i);
            finalName = `${name} ${suffix}`;
        }
        
        const combatant = {
            id: Date.now() + i,
            name: finalName,
            initiative: initiative,
            maxHp: maxHp,
            currentHp: maxHp,
            ac: ac,
            originalMonsterName: window.selectedMonsterInfo ? window.selectedMonsterInfo.originalName : name,
            monsterSource: window.selectedMonsterInfo ? window.selectedMonsterInfo.source : null
        };
        
        combatants.push(combatant);
    }
    
    sortCombatantsByInitiative();
    renderCombatTable();
    clearInputs();
    
    // Clear the selected monster info after adding
    window.selectedMonsterInfo = null;
}

function sortCombatantsByInitiative() {
    combatants.sort((a, b) => b.initiative - a.initiative);
}

function clearInputs() {
    document.getElementById('nameInput').value = '';
    document.getElementById('initiativeInput').value = '';
    document.getElementById('maxHpInput').value = '';
    document.getElementById('acInput').value = '';
    document.getElementById('quantityInput').value = '1';
}

function renderCombatTable() {
    const tbody = document.getElementById('combatBody');
    tbody.innerHTML = '';
    
    combatants.forEach((combatant, index) => {
        const row = document.createElement('tr');
        
        // Add current turn highlighting
        if (index === currentTurnIndex && combatants.length > 0) {
            row.classList.add('current-turn');
        }
        
        row.innerHTML = `
            <td><input type="number" value="${combatant.initiative}" onchange="updateInitiative(${combatant.id}, this.value)" style="border: none; background: transparent; font-size: 16px; width: 35px; font-weight: bold; text-align: center; color: black; padding: 1px;" min="1" max="30"></td>
            <td style="position: relative;">
                <div style="display: flex; align-items: center; height: 100%;">
                    <input type="text" value="${combatant.name}" onchange="updateName(${combatant.id}, this.value)" style="border: none; background: transparent; font-size: 16px; width: calc(100% - 120px); font-weight: bold; color: black; padding: 1px; flex: 1;">
                    ${getMonsterLink(combatant)}
                    <button onclick="removeCombatant(${combatant.id})" title="Remove" style="position: absolute; right: 2px; background-color: #666 !important; color: white !important; border: none !important; padding: 3px 8px !important; cursor: pointer; font-size: 18px !important; font-weight: bold; border-radius: 3px !important; line-height: 16px !important; height: auto !important; min-height: auto !important; box-sizing: border-box !important;">Ã—</button>
                </div>
            </td>
            <td><input type="number" value="${combatant.ac || ''}" onchange="updateAC(${combatant.id}, this.value)" style="border: none; background: transparent; font-size: 16px; width: 35px; font-weight: bold; text-align: center; color: black; padding: 1px;" min="1" max="30" placeholder="-"></td>
            ${combatant.maxHp ? `<td>
                <div class="hp-controls">
                    <button onclick="modifyHp(${combatant.id}, 5)" style="background-color: #666 !important; color: white !important; border: none !important; padding: 3px 8px !important; cursor: pointer; font-size: 16px !important; margin: 0 2px !important; border-radius: 3px !important; line-height: 16px !important; height: auto !important; min-height: auto !important; box-sizing: border-box !important;">+5</button>
                    <button onclick="modifyHp(${combatant.id}, 1)" style="background-color: #666 !important; color: white !important; border: none !important; padding: 3px 8px !important; cursor: pointer; font-size: 16px !important; margin: 0 2px !important; border-radius: 3px !important; line-height: 16px !important; height: auto !important; min-height: auto !important; box-sizing: border-box !important;">+1</button>
                    <input type="text" value="${combatant.currentHp}" onchange="setHp(${combatant.id}, this.value)" style="width: 35px; font-size: 16px; text-align: center; margin: 0 3px; padding: 1px; background-color: white; color: black; border: 1px solid #999;">
                    <span style="font-size: 16px;">/ </span>
                    <input type="number" value="${combatant.maxHp}" onchange="setMaxHp(${combatant.id}, this.value)" min="1" style="width: 35px; font-size: 16px; text-align: center; margin: 0 3px; padding: 1px; background-color: white; color: black; border: 1px solid #999;">
                    <button onclick="modifyHp(${combatant.id}, -1)" style="background-color: #666 !important; color: white !important; border: none !important; padding: 3px 8px !important; cursor: pointer; font-size: 16px !important; margin: 0 2px !important; border-radius: 3px !important; line-height: 16px !important; height: auto !important; min-height: auto !important; box-sizing: border-box !important;">-1</button>
                    <button onclick="modifyHp(${combatant.id}, -5)" style="background-color: #666 !important; color: white !important; border: none !important; padding: 3px 8px !important; cursor: pointer; font-size: 16px !important; margin: 0 2px !important; border-radius: 3px !important; line-height: 16px !important; height: auto !important; min-height: auto !important; box-sizing: border-box !important;">-5</button>
                </div>
            </td>` : '<td>-</td>'}
        `;
        
        tbody.appendChild(row);
    });
}

function modifyHp(id, amount) {
    const combatant = combatants.find(c => c.id === id);
    if (combatant) {
        combatant.currentHp = Math.max(0, Math.min(combatant.maxHp, combatant.currentHp + amount));
        renderCombatTable();
    }
}

function setHp(id, value) {
    const combatant = combatants.find(c => c.id === id);
    if (combatant) {
        const inputString = value.toString().trim();
        
        if (inputString.startsWith('+')) {
            // Number with + sign = healing, add to current HP
            const healAmount = parseInt(inputString.substring(1)) || 0;
            combatant.currentHp = Math.min(combatant.maxHp, combatant.currentHp + healAmount);
        } else if (inputString.startsWith('-')) {
            // Negative number = damage, subtract from current HP
            const damageAmount = parseInt(inputString.substring(1)) || 0;
            combatant.currentHp = Math.max(0, combatant.currentHp - damageAmount);
        } else {
            // Plain number = set HP directly
            const newHp = parseInt(inputString) || 0;
            combatant.currentHp = Math.max(0, Math.min(combatant.maxHp, newHp));
        }
        
        renderCombatTable();
    }
}

function updateName(id, newName) {
    const combatant = combatants.find(c => c.id === id);
    if (combatant) {
        combatant.name = newName.trim() || combatant.name;
        renderCombatTable();
    }
}

function updateInitiative(id, newInitiative) {
    const combatant = combatants.find(c => c.id === id);
    if (combatant) {
        const initiative = parseInt(newInitiative);
        if (!isNaN(initiative) && initiative >= 1 && initiative <= 30) {
            combatant.initiative = initiative;
            
            // Find the current combatant before resorting
            const currentCombatant = combatants[currentTurnIndex];
            
            // Resort the list
            sortCombatantsByInitiative();
            
            // Find where the current combatant ended up after resorting
            if (currentCombatant) {
                currentTurnIndex = combatants.findIndex(c => c.id === currentCombatant.id);
                if (currentTurnIndex === -1) currentTurnIndex = 0;
            }
            
            renderCombatTable();
        }
    }
}

function updateAC(id, newAC) {
    const combatant = combatants.find(c => c.id === id);
    if (combatant) {
        const ac = parseInt(newAC);
        if (!isNaN(ac) && ac >= 1 && ac <= 30) {
            combatant.ac = ac;
            renderCombatTable();
        } else if (newAC.trim() === '') {
            // Allow clearing the AC field
            combatant.ac = null;
            renderCombatTable();
        }
    }
}

function setMaxHp(id, value) {
    const combatant = combatants.find(c => c.id === id);
    if (combatant) {
        const newMaxHp = Math.max(1, parseInt(value) || 1);
        combatant.maxHp = newMaxHp;
        
        // If current HP is higher than new max, adjust it down
        if (combatant.currentHp > newMaxHp) {
            combatant.currentHp = newMaxHp;
        }
        
        renderCombatTable();
    }
}

function removeCombatant(id) {
    const index = combatants.findIndex(c => c.id === id);
    if (index !== -1) {
        combatants.splice(index, 1);
        
        // Adjust current turn index if necessary
        if (currentTurnIndex >= combatants.length) {
            currentTurnIndex = 0;
        }
        
        renderCombatTable();
    }
}

function resetCombat() {
    if (confirm('Are you sure you want to reset the combat? This will remove all combatants.')) {
        combatants = [];
        currentTurnIndex = 0;
        renderCombatTable();
    }
}

function nextTurn() {
    if (combatants.length === 0) return;
    currentTurnIndex = (currentTurnIndex + 1) % combatants.length;
    renderCombatTable();
}

function exportCombat() {
    const combatData = {
        combatants: combatants,
        currentTurnIndex: currentTurnIndex,
        exportDate: new Date().toISOString()
    };
    
    const dataStr = JSON.stringify(combatData, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `combat_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
    link.click();
    
    // Clean up
    URL.revokeObjectURL(link.href);
}

function copyInitiativeText() {
    if (combatants.length === 0) {
        alert('No combatants to export.');
        return;
    }
    
    // Create text with initiative order (just names and initiative)
    let text = "**Initiative**\n";
    combatants.forEach((combatant, index) => {
        text += `- ${combatant.initiative}: ${combatant.name}\n`;
    });
    
    // Copy to clipboard
    navigator.clipboard.writeText(text).then(function() {
        alert('Initiative order copied to clipboard!');
    }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        alert('Initiative order copied to clipboard!');
    });
}

function importCombat(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const combatData = JSON.parse(e.target.result);
            
            // Validate the data structure
            if (!combatData.combatants || !Array.isArray(combatData.combatants)) {
                alert('Invalid combat file format.');
                return;
            }
            
            // Validate each combatant has required fields
            for (const combatant of combatData.combatants) {
                if (!combatant.name || typeof combatant.initiative !== 'number' || !combatant.id) {
                    alert('Invalid combatant data in file.');
                    return;
                }
            }
            
            // Import the data - append to existing combatants instead of replacing
            const newCombatants = combatData.combatants;
            
            // Generate new IDs for imported combatants to avoid conflicts
            newCombatants.forEach(combatant => {
                combatant.id = Date.now() + Math.random();
            });
            
            // Add new combatants to existing list
            combatants.push(...newCombatants);
            
            // Resort by initiative
            sortCombatantsByInitiative();
            
            // Keep current turn index if we had combatants, otherwise start fresh
            if (combatants.length > 0 && currentTurnIndex >= combatants.length) {
                currentTurnIndex = 0;
            }
            
            renderCombatTable();
            
        } catch (error) {
            alert('Error reading combat file. Please check the file format.');
            console.error('Import error:', error);
        }
    };
    
    reader.readAsText(file);
    
    // Clear the input so the same file can be imported again if needed
    event.target.value = '';
}

// Handle Enter key in form inputs
document.addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
        const activeElement = document.activeElement;
        
        if (activeElement.id === 'nameInput') {
            // If monster dropdown is open and one is selected, select it first
            if (selectedMonsterIndex >= 0 && document.getElementById('monsterResults').style.display !== 'none') {
                selectMonsterByIndex(selectedMonsterIndex);
            }
            document.getElementById('initiativeInput').focus();
        } else if (activeElement.id === 'initiativeInput') {
            document.getElementById('maxHpInput').focus();
        } else if (activeElement.id === 'maxHpInput') {
            document.getElementById('acInput').focus();
        } else if (activeElement.id === 'acInput') {
            document.getElementById('quantityInput').focus();
        } else if (activeElement.id === 'quantityInput') {
            addCombatant();
        }
    }
});

// Initialize
renderCombatTable();

// Load monster data when page loads
document.addEventListener('DOMContentLoaded', function() {
    loadMonstersFromJS();
});
</script>

</body>
</html>