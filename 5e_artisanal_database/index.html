<!DOCTYPE html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="robots" content="noindex">
<meta charset="UTF-8">
<link rel="stylesheet" href="./css_js/5eadb.css">
<title>5e Artisanal Database</title>
</head>
<body>
<h1>5e Artisanal Database</h1>

<div class="main-search-container">
    <input 
        type="text" 
        id="mainSearchInput" 
        class="main-search-input" 
        placeholder="Search rules, spells, monsters, and more..." 
        autocomplete="off"
    >
    
    <div class="filter-container">
        <div class="filter-header" onclick="toggleFilters()">
            <h3>Filter by Source</h3>
            <span id="filterToggle" class="filter-toggle collapsed">►</span>
        </div>
        <div id="filterContent" class="filter-content collapsed">
            <div id="sourceFilters" class="source-filters">
                <!-- Checkboxes will be populated dynamically -->
            </div>
            <div class="filter-actions">
                <button type="button" onclick="selectAllSources()">Select All</button>
                <button type="button" onclick="deselectAllSources()">Deselect All</button>
            </div>
        </div>
    </div>
    
    <div class="search-buttons">
        <button type="button" onclick="performSearch(event)">Search</button>
        <button type="button" onclick="performLuckySearch()">First Result</button>
    </div>
</div>

<script src="./css_js/lunr.js"></script>
<script src="./search/search-data.js"></script>
<script>
// Selected sources for filtering
let selectedSources = [];

function performSearch(event) {
    if (event) event.preventDefault(); // Prevent form submission
    
    const searchInput = document.getElementById('mainSearchInput');
    const query = searchInput.value.trim();
    
    // Build URL with query parameter
    let url = './search/index.html';
    const params = [];
    
    if (query) {
        params.push(`q=${encodeURIComponent(query)}`);
    }
    
    // Add filter parameters if any filters are unchecked
    try {
        const allCheckboxes = document.querySelectorAll('#sourceFilters input[type="checkbox"]:not([id^="master-"])');
        const checkedBoxes = document.querySelectorAll('#sourceFilters input[type="checkbox"]:not([id^="master-"]):checked');
        
        // Only add filter params if some checkboxes exist and not all are checked
        if (allCheckboxes.length > 0 && checkedBoxes.length < allCheckboxes.length) {
            const filterParams = encodeSourceFiltersToUrl();
            Object.entries(filterParams).forEach(([param, value]) => {
                params.push(`${param}=${encodeURIComponent(value)}`);
            });
        }
    } catch (error) {
        console.log('Filter encoding failed, proceeding with basic search:', error);
    }
    
    if (params.length > 0) {
        url += '?' + params.join('&');
    }
    
    window.location.href = url;
}

function performLuckySearch() {
    const searchInput = document.getElementById('mainSearchInput');
    const query = searchInput.value.trim();
    
    // Build URL with query and lucky parameter
    let url = './search/index.html';
    const params = [];
    
    if (query) {
        params.push(`q=${encodeURIComponent(query)}`);
    }
    
    params.push('lucky=1');
    
    // Add filter parameters if any filters are unchecked
    try {
        const allCheckboxes = document.querySelectorAll('#sourceFilters input[type="checkbox"]:not([id^="master-"])');
        const checkedBoxes = document.querySelectorAll('#sourceFilters input[type="checkbox"]:not([id^="master-"]):checked');
        
        // Only add filter params if some checkboxes exist and not all are checked
        if (allCheckboxes.length > 0 && checkedBoxes.length < allCheckboxes.length) {
            const filterParams = encodeSourceFiltersToUrl();
            Object.entries(filterParams).forEach(([param, value]) => {
                params.push(`${param}=${encodeURIComponent(value)}`);
            });
        }
    } catch (error) {
        console.log('Filter encoding failed, proceeding with basic search:', error);
    }
    
    url += '?' + params.join('&');
    window.location.href = url;
}

function createSourceCodeMappings() {
    // Create mappings from short codes to full source names (same as search page)
    const mappings = {
        // Common abbreviations
        'srd51': '5.1 SRD',
        'srd52': '5.2 SRD',
        'srd24': 'D&D 2024',
        'a5e': 'Level Up Advanced 5e',
        'vom': 'Vault of Magic',
        'tov': 'Tome of Versatile Magic',
        'monsters': 'Monsters',
        'spells': 'Spells',
        'items': 'Magic Items',
        'basic': 'Basic Rules',
        'dmg': 'Dungeon Master\'s Guide',
        'phb': 'Player\'s Handbook',
        'mm': 'Monster Manual',
        'xgte': 'Xanathar\'s Guide to Everything',
        'tce': 'Tasha\'s Cauldron of Everything',
        'ftd': 'Fizban\'s Treasury of Dragons',
        'mpmm': 'Mordenkainen Presents: Monsters of the Multiverse',
        'blackfla': 'black_flag'
    };
    
    // Auto-generate codes for any sources not manually mapped
    const allSources = new Set();
    if (window.searchDocuments) {
        window.searchDocuments.forEach(doc => {
            if (doc.type === 'ruleset') {
                allSources.add(doc.source);
            } else {
                allSources.add(doc.category);
            }
        });
    }
    
    // Add auto-generated codes for unmapped sources
    Array.from(allSources).forEach(source => {
        if (!Object.values(mappings).includes(source)) {
            // Create a simple code from the source name
            const code = source.toLowerCase()
                .replace(/[^a-z0-9]/g, '')
                .substring(0, 8);
            if (!mappings[code]) {
                mappings[code] = source;
            }
        }
    });
    
    return mappings;
}

function encodeSourceFiltersToUrl() {
    const params = {};
    
    // Create source code mappings (same as search page)
    const sourceCodeMappings = createSourceCodeMappings();
    const reverseMapping = Object.fromEntries(
        Object.entries(sourceCodeMappings).map(([code, source]) => [source, code])
    );
    
    // Collect selected sources by type
    const selectedByType = {
        r: [], // rulesets
        m: [], // monsters  
        s: [], // spells
        i: []  // magic items
    };
    
    // Check each checkbox
    document.querySelectorAll('#sourceFilters input[type="checkbox"]:checked').forEach(checkbox => {
        if (checkbox.id.startsWith('master-')) return; // Skip master checkboxes
        
        const type = checkbox.dataset.type;
        const source = checkbox.dataset.source;
        const code = reverseMapping[source];
        
        if (code) {
            if (type === 'ruleset') {
                selectedByType.r.push(code);
            } else if (type === 'monsters') {
                selectedByType.m.push(code);
            } else if (type === 'spells') {
                selectedByType.s.push(code);
            } else if (type === 'magic_items') {
                selectedByType.i.push(code);
            }
        }
    });
    
    // Only add parameters that have selections
    Object.entries(selectedByType).forEach(([param, codes]) => {
        if (codes.length > 0) {
            params[param] = codes.join(',');
        }
    });
    
    return params;
}

function toggleFilters() {
    const filterToggle = document.getElementById('filterToggle');
    const filterContent = document.getElementById('filterContent');
    
    filterToggle.classList.toggle('collapsed');
    filterContent.classList.toggle('collapsed');
}

function setupSourceFilters() {
    if (!window.searchDocuments || window.searchDocuments.length === 0) {
        return;
    }
    
    // Organize documents by type (same as search page)
    const rulesets = new Set();
    const databases = {
        monsters: new Set(),
        spells: new Set(),
        magic_items: new Set()
    };
    
    window.searchDocuments.forEach(doc => {
        if (doc.type === 'ruleset') {
            rulesets.add(doc.source);
        } else if (doc.type in databases) {
            databases[doc.type].add(doc.category);
        }
    });
    
    const filtersContainer = document.getElementById('sourceFilters');
    filtersContainer.innerHTML = '';
    
    // Create Rulesets section
    if (rulesets.size > 0) {
        const rulesetsSection = document.createElement('div');
        rulesetsSection.className = 'filter-section';
        
        const rulesetsTitle = document.createElement('div');
        rulesetsTitle.className = 'filter-section-title';
        
        const masterCheckbox = document.createElement('input');
        masterCheckbox.type = 'checkbox';
        masterCheckbox.id = 'master-rulesets';
        masterCheckbox.checked = true;
        masterCheckbox.addEventListener('change', (e) => {
            e.stopPropagation();
            toggleAllInSection('ruleset');
        });
        
        const titleText = document.createElement('span');
        titleText.textContent = 'Rulesets';
        titleText.onclick = () => toggleSection('rulesets');
        
        const toggleIcon = document.createElement('span');
        toggleIcon.className = 'section-toggle collapsed';
        toggleIcon.textContent = '►';
        toggleIcon.onclick = () => toggleSection('rulesets');
        
        rulesetsTitle.appendChild(masterCheckbox);
        rulesetsTitle.appendChild(titleText);
        rulesetsTitle.appendChild(toggleIcon);
        rulesetsSection.appendChild(rulesetsTitle);
        
        const subsection = document.createElement('div');
        subsection.className = 'filter-subsection collapsed';
        subsection.id = 'section-rulesets';
        
        Array.from(rulesets).sort().forEach(ruleset => {
            const filterDiv = document.createElement('div');
            filterDiv.className = 'source-filter';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `filter-ruleset-${ruleset.replace(/[^a-zA-Z0-9]/g, '')}`;
            checkbox.value = `ruleset-${ruleset}`;
            checkbox.checked = true;
            checkbox.dataset.type = 'ruleset';
            checkbox.dataset.source = ruleset;
            checkbox.dataset.section = 'rulesets';
            
            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = ruleset;
            
            filterDiv.appendChild(checkbox);
            filterDiv.appendChild(label);
            subsection.appendChild(filterDiv);
            
            checkbox.addEventListener('change', () => {
                updateMasterCheckbox('rulesets');
            });
        });
        
        rulesetsSection.appendChild(subsection);
        filtersContainer.appendChild(rulesetsSection);
    }
    
    // Create Database sections
    const dbTypeNames = {
        monsters: 'Monsters',
        spells: 'Spells', 
        magic_items: 'Magic Items'
    };
    
    Object.entries(databases).forEach(([dbType, sources]) => {
        if (sources.size > 0) {
            const dbSection = document.createElement('div');
            dbSection.className = 'filter-section';
            
            const dbTitle = document.createElement('div');
            dbTitle.className = 'filter-section-title';
            
            const masterCheckbox = document.createElement('input');
            masterCheckbox.type = 'checkbox';
            masterCheckbox.id = `master-${dbType}`;
            masterCheckbox.checked = true;
            masterCheckbox.addEventListener('change', (e) => {
                e.stopPropagation();
                toggleAllInSection(dbType);
            });
            
            const titleText = document.createElement('span');
            titleText.textContent = dbTypeNames[dbType];
            titleText.onclick = () => toggleSection(dbType);
            
            const toggleIcon = document.createElement('span');
            toggleIcon.className = 'section-toggle collapsed';
            toggleIcon.textContent = '►';
            toggleIcon.onclick = () => toggleSection(dbType);
            
            dbTitle.appendChild(masterCheckbox);
            dbTitle.appendChild(titleText);
            dbTitle.appendChild(toggleIcon);
            dbSection.appendChild(dbTitle);
            
            const subsection = document.createElement('div');
            subsection.className = 'filter-subsection collapsed';
            subsection.id = `section-${dbType}`;
            
            Array.from(sources).sort().forEach(source => {
                const filterDiv = document.createElement('div');
                filterDiv.className = 'source-filter';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-${dbType}-${source.replace(/[^a-zA-Z0-9]/g, '')}`;
                checkbox.value = `${dbType}-${source}`;
                checkbox.checked = true;
                checkbox.dataset.type = dbType;
                checkbox.dataset.source = source;
                checkbox.dataset.section = dbType;
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = source;
                
                filterDiv.appendChild(checkbox);
                filterDiv.appendChild(label);
                subsection.appendChild(filterDiv);
                
                checkbox.addEventListener('change', () => {
                    updateMasterCheckbox(dbType);
                });
            });
            
            dbSection.appendChild(subsection);
            filtersContainer.appendChild(dbSection);
        }
    });
}

function toggleSection(sectionName) {
    const section = document.getElementById(`section-${sectionName}`);
    const toggle = section.previousElementSibling.querySelector('.section-toggle');
    
    if (section.classList.contains('collapsed')) {
        section.classList.remove('collapsed');
        toggle.classList.remove('collapsed');
        toggle.textContent = '▼';
    } else {
        section.classList.add('collapsed');
        toggle.classList.add('collapsed');
        toggle.textContent = '►';
    }
}

function toggleAllInSection(sectionType) {
    const masterCheckbox = document.getElementById(`master-${sectionType}`);
    const sectionCheckboxes = document.querySelectorAll(`#sourceFilters input[data-section="${sectionType}"]`);
    
    sectionCheckboxes.forEach(checkbox => {
        checkbox.checked = masterCheckbox.checked;
    });
}

function updateMasterCheckbox(sectionType) {
    const masterCheckbox = document.getElementById(`master-${sectionType}`);
    const sectionCheckboxes = document.querySelectorAll(`#sourceFilters input[data-section="${sectionType}"]`);
    const checkedBoxes = document.querySelectorAll(`#sourceFilters input[data-section="${sectionType}"]:checked`);
    
    if (checkedBoxes.length === 0) {
        masterCheckbox.checked = false;
        masterCheckbox.indeterminate = false;
    } else if (checkedBoxes.length === sectionCheckboxes.length) {
        masterCheckbox.checked = true;
        masterCheckbox.indeterminate = false;
    } else {
        masterCheckbox.checked = false;
        masterCheckbox.indeterminate = true;
    }
}

function selectAllSources() {
    document.querySelectorAll('#sourceFilters input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = true;
    });
    // Update all master checkboxes
    document.querySelectorAll('#sourceFilters input[id^="master-"]').forEach(master => {
        master.checked = true;
        master.indeterminate = false;
    });
}

function deselectAllSources() {
    document.querySelectorAll('#sourceFilters input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
    });
}

// Initialize filters when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for search data to load
    setTimeout(setupSourceFilters, 100);
});

// Allow Enter key to trigger search
document.getElementById('mainSearchInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        performSearch(e);
    }
});
</script>

<h2>Rulesets</h2>
<ul>
<li><a href="./rules/html/5.1 SRD (D&D 2014)/index.html">5.1 SRD (D&D 2014)</a></li>
<li><a href="./rules/html/5.2 SRD (D&D 2024)/index.html">5.2 SRD (D&D 2024)</a></li>
<li><a href="./rules/html/Black Flag (Tales of the Valiant)/index.html">Black Flag (Tales of the Valiant)</a></li>
<li><a href="./rules/html/Level Up Advanced 5e/index.html">Level Up Advanced 5e</a></li>
<li><a href="./rules/html/Lazy%20GM%20Resource%20Docs/index.html">Lazy GM's Resource Document</a></li>
<li><a href="./rules/html/Lazy%20GM%20Monster%20Docs/index.html">Lazy GM's Monster Resource Document</a></li>
</ul>

<h2>Databases</h2>
<ul>
<li><a href="./monsters/index.html">Monsters</a></li>
<li><a href="./spells/index.html">Spells</a></li>
<li><a href="./magic_items/index.html">Magic Items</a></li>
</ul>

<h2>Tools</h2>
<ul>
<li><a href="./tools/dice_roller/index.html">Dice Roller</a></li>
<li><a href="./tools/encounter_calculator/index.html">Encounter Calculator</a></li>
<li><a href="./tools/combat_tracker/index.html">Combat Tracker</a></li>
<li><a href="./tools/fof_monster_stats/index.html">Quick Monster Stats</a></li>
<li><a href="./tools/token_maker/index.html">Token Maker</a></li>
<li><a href="./tools/annotator/index.html">Map Annotator</a></li>
<li><a href="https://slyflourish.com/sf_patreon_files_898123050001223/dyson_maps.html">Dyson Commercial Map Gallery</a> (External Link)</li>
</ul>

<h2>Random Generators</h2>
<ul>
<li><a href="./generators/npcs/index.html">NPCs</a></li>
<li><a href="./generators/monuments/index.html"">Monuments</a></li>
<li><a href="./generators/locations/index.html"">Locations</a></li>
<li><a href="./generators/traps/index.html"">Traps</a></li>
<li><a href="./generators/treasure/index.html"">Lazy 5e Treasure</a></li>
<li><a href="./generators/scrolls/index.html">Scrolls</a></li>
<li><a href="./generators/spellbook/index.html">Spellbooks</a></li>
<li><a href="./generators/2024_dnd_treasure/index.html">2024 D&D Treasure</a></li>
<li><a href="./generators/tov_treasure/index.html">Tales of the Valiant Treasure</a></li>
<li><a href="./generators/relics/index.html">Relics (single-use magic items)</a></li>
<li><a href="./generators/dm_relics/index.html">Deep Magic Relics</a></li>
<li><a href="./generators/weapons/index.html">Unique Weapons</a></li>
<li><a href="./generators/armor/index.html">Unique Armor</a></li>
<li><a href="./generators/generator_template/index.html">Generator Template</a></li>
</ul>

<h2>About the 5e Artisanal Database</h2>

<p>The 5e Artisanal Database is a database of open-licensed content for your 5e-based tabletop roleplaying games. Mobile friendly, downloadable, and self-hostable using your own web server or locally using your own web browser. <a href="5e_artisanal_database.zip">Download your own copy</a>.</p>

<p>The 5e Artisanal Database is a feature for <a href="https://www.patreon.com/c/slyflourish">Patreons of Sly Flourish</a>. If you are not a patron, please <a href="https://www.patreon.com/c/slyflourish">join up</a> to support this work and get access to a whole lot more.</a>

<h2>Sources</h2>
<p>The 5e Artisanal Database collects rules and tools for several openly-released 5e roleplaying game systems including the <a href="./srds/SRD_CC_v5.1.pdf">D&D 2014 5.1 SRD</a>, the <a href="./srds/SRD_CC_v5.2.1.pdf">D&D 2024 5.2 SRD</a>, <a href="https://a5esrd.com/a5esrd">Level Up Advanced 5e</a>, <a href="https://koboldpress.com/kpstore/product/tome-of-beasts-1-2023-edition/">Tome of Beasts 1</a>, <a href="https://koboldpress.com/tome-of-beasts-2/">2</a>, <a href="https://koboldpress.com/kpstore/product/tome-of-beasts-3-for-5th-edition/">3</a>, the <a href="https://koboldpress.com/kpstore/product/creature-codex-for-5th-edition-dnd/">Creature Codex</a>, the <a href="./srds/Black-Flag-Roleplaying.pdf">Kobold Press Black Flag SRD</a>, the <a href="https://slyflourish.com/lazy_gm_resource_document.html">Lazy GM's Resource Document</a>, and the <a href="https://slyflourish.com/lazy_5e_monster_building_resource_document.html">Lazy GM's Monster Resource Document</a>. See <a href="./licensing.html">Licensing</a> for license details.</p>


</body>
</html>